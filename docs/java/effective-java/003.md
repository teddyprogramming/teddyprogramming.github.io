# Item 3: Enforce the singleton property with a private constructor or an enum type

Singleton pattern 確保一個類別只有一個實例，並提供全域存取點。在 Java 中，有三種主要的實作方式，每種都有其優缺點。

## Singleton 的實作方式

### 方法一：Public Final Field (公開最終欄位)

將 constructor 設為 private，並提供一個 public static final field 來存放唯一的實例：

```java
// Singleton with public final field
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();

    private Elvis() {
        // 防止反射攻擊
        if (INSTANCE != null) {
            throw new RuntimeException("Use getInstance() method to get the single instance of this class.");
        }
    }

    public void leaveTheBuilding() {
        System.out.println("Elvis has left the building!");
    }
}
```

**使用方式：**

```java
Elvis elvis = Elvis.INSTANCE;
elvis.leaveTheBuilding();
```

**優點：**

- **簡潔明確**：API 清楚表明這是一個 singleton
- **效能良好**：沒有額外的方法呼叫開銷
- **執行緒安全**：JVM 保證 static 欄位的初始化是執行緒安全的

**缺點：**

- **彈性較差**：無法在不修改 API 的情況下改變 singleton 行為
- **測試困難**：難以進行單元測試時的 mock

### 方法二：Static Factory Method (靜態工廠方法)

將 constructor 設為 private，並提供一個 public static 方法回傳唯一的實例：

```java
// Singleton with static factory
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();

    private Elvis() {
        // 防止反射攻擊
        if (INSTANCE != null) {
            throw new RuntimeException("Use getInstance() method to get the single instance of this class.");
        }
    }

    public static Elvis getInstance() {
        return INSTANCE;
    }

    public void leaveTheBuilding() {
        System.out.println("Elvis has left the building!");
    }
}
```

**使用方式：**

```java
Elvis elvis = Elvis.getInstance();
elvis.leaveTheBuilding();
```

**優點：**

- **彈性佳**：可以在不改變 API 的情況下修改實作（例如改為非 singleton）
- **支援泛型**：可以建立泛型 singleton factory
- **方法參考友善**：`Elvis::getInstance` 可以用作 `Supplier<Elvis>`
- **延遲初始化**：可以實作延遲載入 (lazy loading)

**缺點：**

- **稍微複雜**：比方法一多了一層方法呼叫

### 方法三：Single-Element Enum (推薦)

使用只有一個元素的 enum 來實作 singleton：

```java
public enum Elvis {
    INSTANCE;

    public void leaveTheBuilding() {
        System.out.println("Elvis has left the building!");
    }

    // 可以新增其他方法
    public void sing(String song) {
        System.out.println("Elvis is singing: " + song);
    }
}
```

**使用方式：**

```java
Elvis elvis = Elvis.INSTANCE;
elvis.leaveTheBuilding();
elvis.sing("Love Me Tender");
```

**優點：**

- **簡潔**：程式碼最簡潔
- **序列化安全**：免費獲得序列化支援，無需額外處理
- **反射安全**：天然防止反射攻擊
- **執行緒安全**：JVM 保證 enum 的執行緒安全性

**缺點：**

- **繼承限制**：無法繼承其他類別 (但可以實作介面)

## 序列化考量

對於方法一和方法二，如果需要支援序列化，必須：

1. 實作 `Serializable` 介面
2. 將所有欄位宣告為 `transient`
3. 提供 `readResolve` 方法：

```java
// 確保序列化後仍維持 singleton 特性
private Object readResolve() {
    return INSTANCE;
}
```

!!! warning "序列化陷阱"

    沒有正確處理序列化的 singleton 可能在反序列化時產生新的實例，破壞 singleton 的唯一性。

## 反射攻擊防護

對於方法一和方法二，可以在 constructor 中加入防護：

```java
private Elvis() {
    if (INSTANCE != null) {
        throw new RuntimeException("Cannot create instance via reflection");
    }
}
```

## 最佳實務建議

### 推薦使用 Enum 方式

!!! tip "最佳選擇"

    **Single-element enum 是實作 singleton 的最佳方式**，除非需要繼承其他類別。它提供了最簡潔、最安全的實作。

### 何時使用 Static Factory Method

當需要以下特性時，考慮使用 static factory method：

- **延遲初始化**：只有在第一次呼叫時才建立實例
- **條件性建立**：根據條件決定是否建立實例
- **泛型支援**：需要泛型 singleton factory

### 延遲初始化範例

```java
public class LazyElvis {
    private static volatile LazyElvis instance;

    private LazyElvis() {}

    public static LazyElvis getInstance() {
        if (instance == null) {
            synchronized (LazyElvis.class) {
                if (instance == null) {
                    instance = new LazyElvis();
                }
            }
        }
        return instance;
    }
}
```

## 總結

| 方式 | 簡潔性 | 彈性 | 序列化安全 | 反射安全 | 推薦程度 |
|------|--------|------|------------|----------|----------|
| Single-Element Enum | ⭐⭐⭐ | ⭐⭐ | ✅ | ✅ | ⭐⭐⭐⭐⭐ |
| Public Final Field | ⭐⭐⭐ | ⭐ | ❌ | ⚠️ | ⭐⭐ |
| Static Factory Method | ⭐⭐ | ⭐⭐⭐ | ❌ | ⚠️ | ⭐⭐⭐ |

**註解：**
- ✅ 原生支援
- ❌ 不支援/需要額外處理
- ⚠️ 需要手動在 constructor 中加入檢查來防護

**結論**：除非有特殊需求，否則建議使用 **single-element enum** 來實作 singleton pattern。
