# Item 4: Enforce noninstantiability with a private constructor

工具類別 (Utility Class)通常只包含靜態方法和靜態欄位，不應該被實例化。Java 提供了一個簡單而有效的方法來防止類別被實例化：使用 private constructor。

## 問題：預設 Constructor 的陷阱

在 Java 中，如果類別沒有明確定義任何 constructor，編譯器會自動提供一個 public 的預設 constructor：

```java
// 錯誤示範：沒有明確 constructor
public class MathUtils {
    public static int add(int a, int b) {
        return a + b;
    }

    public static int multiply(int a, int b) {
        return a * b;
    }
}

// 問題：可以被實例化！
MathUtils utils = new MathUtils(); // 這不應該被允許
```

這樣的設計有以下問題：

- **語意不清**：工具類別不應該有實例
- **資源浪費**：不必要的物件建立
- **設計意圖不明確**：使用者可能誤以為需要建立實例

## 解決方案：Private Constructor

### 基本實作

使用 private constructor 來防止實例化：

```java
// 正確的工具類別實作
public class UtilityClass {
    // Suppress default constructor for noninstantiability
    private UtilityClass() {
        throw new AssertionError("This class cannot be instantiated");
    }

    public static void performUtilityOperation() {
        // 工具方法實作
        System.out.println("Performing utility operation");
    }

    public static int calculateSomething(int value) {
        return value * 2;
    }
}
```

### 為什麼要拋出例外？

在 private constructor 中拋出例外有以下好處：

1. **防止內部意外呼叫**：避免類別內部程式碼意外建立實例
2. **明確錯誤訊息**：提供清楚的錯誤說明
3. **文檔化意圖**：程式碼自我說明不可實例化的特性

```java
private UtilityClass() {
    throw new AssertionError("This class cannot be instantiated");
}
```

## 實際範例

### Java 標準函式庫的範例

Java 標準函式庫中有許多這樣的工具類別：

```java
// java.lang.Math
public final class Math {
    private Math() {}  // 防止實例化

    public static final double E = 2.7182818284590452354;
    public static final double PI = 3.14159265358979323846;

    public static double abs(double a) { ... }
    public static double max(double a, double b) { ... }
}

// java.util.Arrays
public class Arrays {
    private Arrays() {}  // 防止實例化

    public static void sort(int[] a) { ... }
    public static String toString(int[] a) { ... }
}

// java.util.Collections
public class Collections {
    private Collections() {}  // 防止實例化

    public static <T> void sort(List<T> list) { ... }
    public static <T> List<T> emptyList() { ... }
}
```

### 自訂工具類別範例

```java
// 字串工具類別
public class StringUtils {
    private StringUtils() {
        throw new AssertionError("StringUtils cannot be instantiated");
    }

    public static boolean isEmpty(String str) {
        return str == null || str.length() == 0;
    }

    public static String capitalize(String str) {
        if (isEmpty(str)) {
            return str;
        }
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }

    public static String reverse(String str) {
        if (isEmpty(str)) {
            return str;
        }
        return new StringBuilder(str).reverse().toString();
    }
}

// 數學工具類別
public class MathUtils {
    private MathUtils() {
        throw new AssertionError("MathUtils cannot be instantiated");
    }

    public static boolean isPrime(int number) {
        if (number <= 1) return false;
        if (number <= 3) return true;
        if (number % 2 == 0 || number % 3 == 0) return false;

        for (int i = 5; i * i <= number; i += 6) {
            if (number % i == 0 || number % (i + 2) == 0) {
                return false;
            }
        }
        return true;
    }

    public static int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

## 額外效果：防止繼承

Private constructor 還有一個副作用：**防止類別被繼承**。

```java
public class BaseUtility {
    private BaseUtility() {
        throw new AssertionError("Cannot instantiate");
    }

    public static void doSomething() {
        System.out.println("Doing something");
    }
}

// 編譯錯誤：無法繼承
public class ExtendedUtility extends BaseUtility {  // ❌ 編譯失敗
    // 子類別無法呼叫父類別的 constructor
}
```

這是因為：

- 每個 constructor 都必須呼叫父類別的 constructor
- 如果父類別只有 private constructor，子類別無法存取
- 因此無法建立子類別

## 設計考量

### 何時使用這個模式

適合使用 private constructor 的情況：

✅ **純工具類別**：只包含靜態方法的類別
✅ **常數集合**：只包含 public static final 欄位的類別
✅ **工廠類別**：只提供 static factory methods 的類別

### 何時不適合使用

❌ **需要狀態的類別**：需要實例欄位的類別
❌ **需要繼承的類別**：設計為父類別的抽象類別
❌ **可能需要多個實例的類別**：如 builder pattern 中的 builder 類別

## 最佳實務

### 1. 加入清楚的註解

```java
public class FileUtils {
    /**
     * Private constructor to prevent instantiation.
     * This class is intended to be used as a utility class.
     */
    private FileUtils() {
        throw new AssertionError("FileUtils cannot be instantiated");
    }

    // ... 靜態方法
}
```

### 2. 使用有意義的例外訊息

```java
private UtilityClass() {
    throw new AssertionError("UtilityClass is a utility class and cannot be instantiated");
}
```

### 3. 考慮使用 final 修飾符

```java
public final class Constants {  // final 防止繼承
    private Constants() {
        throw new AssertionError("Constants class cannot be instantiated");
    }

    public static final String DEFAULT_ENCODING = "UTF-8";
    public static final int MAX_RETRY_COUNT = 3;
}
```

## 總結

Private constructor 是防止類別實例化的簡單而有效的方法：

✅ **防止實例化**：確保工具類別不會被誤用
✅ **防止繼承**：額外的安全保護
✅ **自我文檔化**：程式碼清楚表達設計意圖
✅ **執行期安全**：透過例外處理提供執行期保護

!!! tip "最佳實務"

    對於只包含靜態成員的工具類別，**總是**使用 private constructor 來防止實例化。這是一個簡單但重要的實務，能讓你的 API 更加清晰和安全。
