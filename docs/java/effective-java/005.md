# Item 5: Prefer dependency injection to hardwiring resources

當類別依賴於底層資源時，不要使用 singleton 或 static utility class。相反地，應該將資源透過 constructor (或 static factory 或 builder) 傳入，這種技術稱為 **dependency injection**。

## 問題：寫死資源依賴

考慮拼字檢查器的實作：

### ❌ 錯誤方式：Static Utility 或 Singleton

```java
// 錯誤：寫死依賴
public class SpellChecker {
    private static final Lexicon dictionary = new EnglishDictionary(); // 寫死！

    public static boolean isValid(String word) {
        return dictionary.contains(word);
    }
}
```

**問題：**

- 缺乏彈性：只能使用英文字典
- 難以測試：無法使用 mock 物件
- 違反單一職責：同時管理資源和提供功能

## ✅ 解決方案：Dependency Injection

### 基本實作

```java
public class SpellChecker {
    private final Lexicon dictionary;

    public SpellChecker(Lexicon dictionary) {
        this.dictionary = Objects.requireNonNull(dictionary);
    }

    public boolean isValid(String word) {
        return dictionary.contains(word);
    }
}

// 使用方式
SpellChecker englishChecker = new SpellChecker(new EnglishDictionary());
SpellChecker frenchChecker = new SpellChecker(new FrenchDictionary());
```

### 其他實作方式

**Static Factory：**

```java
public static SpellChecker createEnglishChecker(Lexicon dictionary) {
    return new SpellChecker(dictionary, false); // 預設不區分大小寫
}
```

**Builder Pattern：**

```java
SpellChecker checker = new SpellChecker.Builder(dictionary)
    .caseSensitive(true)
    .maxSuggestions(5)
    .build();
```

**Factory Method：**

```java
public SpellChecker(Supplier<Lexicon> dictionaryFactory) {
    this.dictionary = dictionaryFactory.get();
}
```

## DI 框架

複雜應用可使用 DI 框架：Spring、Guice、Dagger

```java
@Service
public class SpellChecker {
    @Autowired
    public SpellChecker(Lexicon dictionary) {
        this.dictionary = dictionary;
    }
}
```

## 總結

!!! tip "核心原則"
    **不要使用 singleton 或 static utility class 來實作依賴於底層資源的類別**。

**優點：**

✅ 彈性：支援多種實作
✅ 可測試性：可注入 mock 物件
✅ 可重用性：同一類別配合不同資源

**方式選擇：**

- 簡單依賴：Constructor Injection
- 預設配置：Static Factory
- 複雜配置：Builder Pattern
