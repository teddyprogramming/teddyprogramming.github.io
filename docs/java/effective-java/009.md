# Item 9: Prefer try-with-resources to try-finally

使用 try-with-resources 取代 try-finally 來管理資源。

## 為什麼使用 try-with-resources？

- **程式碼更簡潔**：自動管理資源關閉
- **例外處理更好**：不會遺失原始例外訊息
- **避免資源洩漏**：確保資源正確關閉

## 基本使用方式

### 單一資源

```java
// 類別需實作 AutoCloseable
try (FileInputStream input = new FileInputStream(file)) {
    // 使用資源
} // 自動呼叫 close()，即使發生例外
```

### 多個資源

```java
try (FileInputStream input = new FileInputStream(file1);
     FileOutputStream output = new FileOutputStream(file2)) {
    // 使用多個資源
} // 按相反順序自動關閉
```

## 例外處理優勢詳解

假設我們在處理檔案時遇到問題：

### try-finally 的問題：重要例外被隱藏

```java
FileInputStream input = null;
try {
    input = new FileInputStream("不存在的檔案.txt");
    // 這裡會拋出 FileNotFoundException
} finally {
    if (input != null) {
        input.close(); // 假設這裡也拋出 IOException
    }
}
```

**結果**：只會看到 `finally` 區塊的 `IOException`，真正的原因 `FileNotFoundException` 被隱藏了！

### try-with-resources 的解決方案：保留重要訊息

```java
try (FileInputStream input = new FileInputStream("不存在的檔案.txt")) {
    // 這裡會拋出 FileNotFoundException
} // close() 假設也拋出 IOException
```

**結果**：

- 主要例外：`FileNotFoundException` (真正的問題原因)
- Suppressed：`IOException`（附加資訊，不會遮蔽主要問題）

### 為什麼這很重要？

想像你在除錯一個複雜的應用程式：

```java
// ❌ try-finally：看到的錯誤訊息
Exception in thread "main" java.io.IOException: Stream closed
    at java.io.FileInputStream.close(...)

// 你會想：「為什麼 stream 是 closed？」
// 但真正的問題（檔案不存在）被隱藏了！
```

```java
// ✅ try-with-resources：看到的錯誤訊息
Exception in thread "main" java.io.FileNotFoundException: 不存在的檔案.txt
    at java.io.FileInputStream.<init>(...)
    Suppressed: java.io.IOException: Stream closed
        at java.io.FileInputStream.close(...)

// 你立刻知道：「檔案不存在」是真正的問題！
```

## 重點整理

✅ **優勢**：

- 程式碼簡潔，自動資源管理
- 正確的例外處理（不會遺失重要例外）
- 支援多個資源同時管理

✅ **使用條件**：

- 資源類別必須實作 `AutoCloseable` 介面

!!! tip "最佳實務"
    優先使用 try-with-resources，只有在無法使用時才考慮 try-finally。
