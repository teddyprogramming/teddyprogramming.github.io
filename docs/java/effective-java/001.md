# Item 1: Consider static factory methods instead of constructors

Static factory methods 是一種替代 constructor 的物件建立方式，提供了許多優點但也有一些限制。

## 優點

### 1. 提供有意義的名稱

Static factory methods 可以提供更具表達性的名稱，讓程式碼更容易理解：

- `BigInteger.probablePrime()` 比 `BigInteger(int, int, Random)` 更容易理解其用途
- Constructor 只能透過參數型別來區隔，開發人員需要記住不同 constructor 的具體用途
- 容易混淆的例子：`BigInteger(int[])`, `BigInteger(int[], int)`, `BigInteger(int, int[])`

### 2. 不必每次都建立新物件

通過 static factory methods 可以控制物件的建立：

- 套用 **Flyweight pattern** 和 **Singleton pattern**
- 避免建立不必要的重複物件
- 實現 **Instance-controlled class** (實例控制類別)

### 3. 可以回傳子類別

Static factory methods 能夠回傳宣告回傳型別的任何子類別：

- 支援 **interface-based frameworks**
- 降低 [conceptual weight](https://en.wikiversity.org/wiki/Software_Design/Interface_size)：減少開發人員需要掌握的概念

!!! info "Java 8 以前的實作方式"
    在 Java 8 以前，interface 不能有 static method。需要 static factory methods 的類別會命名成 `Type + s` 的形式，並將 constructor 宣告成 private，例如 `Collections`、`Arrays`。

### 4. 依據條件回傳不同的子類別

可以根據輸入參數或執行環境回傳不同的實作類別：

- 允許不同版本更換回傳的子類別，而不影響客戶端程式碼
- **範例：`EnumSet` 的實作**

```java
// EnumSet 根據 enum 數量選擇不同的實作
class EnumSet {
    static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
        if (elementType.getEnumCount() <= 64)
            return new RegularEnumSet(..);
        else
            return new JumboEnumSet(..);
    }
}
```

條件判斷邏輯（如 `<= 64`）和具體的子類別實作都可以改變，而不會影響呼叫端的程式碼。

### 5. 在撰寫時類別不必存在

這個特性特別適用於 **service provider frameworks**：

- 框架開發者不需要預先知道所有可能的介面實作
- 讓介面實作延遲到開發時決定
- **JDBC 範例**：`Connection` interface 可以在開發時透過設定決定具體實作
  ```properties
  spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
  ```
- 支援 **Bridge pattern**
- 可以與 **Dependency Injection frameworks** 整合
- 可搭配 `ServiceLoader` 使用

## 限制

### 1. 拋棄繼承能力

- 如果將 constructor 宣告為 `private` 或 `protected`，子類別無法初始化父類別，導致無法繼承
- 失去繼承能力意味著放棄了 **polymorphism** 的特性

!!! question "思考問題"
    如果同時保留 static factory methods 並將 constructor 宣告為 `public` 會如何？

### 2. 增加除錯難度

由於物件建立的邏輯隱藏在 static factory methods 中，除錯時較難直接追蹤：

- 無法直接看到物件建立的位置
- 難以了解物件的具體建立方式

## 命名慣例

為了提高可讀性，以下是常見的 static factory method 命名規則：

### `from`

**型別轉換方法**：從**一個**型別轉換為另一個型別

```java
Date.from(instant)
```

### `of`

**聚合方法**：從**多個**參數建立物件

```java
EnumSet.of(JACK, QUEEN, KING)
LocalDate.of(2024, 7, 4)
```

### `valueOf`

比 `from` 和 `of` 更詳細的版本

```java
Integer.valueOf("100")
Integer.valueOf("100", 2)  // 指定進位制
```

### `instance` / `getInstance`

從**零個**到**多個**參數建立物件，但不保證每次回傳相同物件

```java
Calendar.getInstance()
Calendar.getInstance(TimeZone.getDefault())
```

### `create` / `newInstance`

從**零個**到**多個**參數建立物件，保證每次建立新物件

```java
Array.newInstance(Integer.class, 10)
```

### `getType`

回傳指定型別的物件，但不保證每次回傳相同物件

```java
Files.getFileStore(path)
```

### `newType`

回傳指定型別的新物件，保證每次建立新物件

```java
BufferedReader br = Files.newBufferedReader(path)
```

### `type`

`getType` 和 `newType` 的簡化版本

```java
Collections.singletonList("apple")
```

## 總結

Static factory methods 是建立物件的有力工具，提供了比 constructor 更大的彈性和表達力。雖然有一些限制，但在大多數情況下，其優點遠超過缺點。建議在設計 API 時優先考慮使用 static factory methods。
 