# Item 2: Consider a builder when faced with many constructor parameters

當類別的 constructor 或 static factory method 有太多參數時，會讓程式碼難以閱讀和維護。在這種情況下，Builder pattern 是一個優秀的解決方案。

## 問題：參數過多的困擾

當一個類別需要很多參數時，傳統的解決方式會遇到以下問題：

- **可讀性差**：呼叫時難以理解每個參數的意義
- **易出錯**：參數順序容易搞混
- **擴展性差**：新增參數時需要修改所有呼叫點

## 解決方案比較

### 1. Telescoping Constructor Pattern (不推薦)

這是一種常見但不理想的解決方式：

```java
public class NutritionFacts {
    private final int servingSize;  // (mL)            required
    private final int servings;     // (per container) required
    private final int calories;     // (per serving)   optional
    private final int fat;          // (g/serving)     optional
    private final int sodium;       // (mg/serving)    optional
    private final int carbohydrate; // (g/serving)     optional

    public NutritionFacts(int servingSize, int servings) {
        this(servingSize, servings, 0);
    }

    public NutritionFacts(int servingSize, int servings, int calories) {
        this(servingSize, servings, calories, 0);
    }

    public NutritionFacts(int servingSize, int servings, int calories, int fat) {
        this(servingSize, servings, calories, fat, 0);
    }

    public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) {
        this(servingSize, servings, calories, fat, sodium, 0);
    }

    public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) {
        this.servingSize  = servingSize;
        this.servings     = servings;
        this.calories     = calories;
        this.fat          = fat;
        this.sodium       = sodium;
        this.carbohydrate = carbohydrate;
    }
}
```

**缺點：**

- 隨著 optional 參數增加，constructor 數量爆炸式成長
- 程式碼可讀性和維護性都很差
- 容易傳錯參數位置

### 2. JavaBeans Pattern (不推薦)

使用無參數 constructor 搭配 setter 方法：

```java
public class NutritionFacts {
    // 初始化為預設值
    private int servingSize  = -1; // Required; no default value
    private int servings     = -1; // Required; no default value
    private int calories     = 0;
    private int fat          = 0;
    private int sodium       = 0;
    private int carbohydrate = 0;

    public NutritionFacts() { }

    // Setters
    public void setServingSize(int val)  { servingSize = val; }
    public void setServings(int val)     { servings = val; }
    public void setCalories(int val)     { calories = val; }
    public void setFat(int val)          { fat = val; }
    public void setSodium(int val)       { sodium = val; }
    public void setCarbohydrate(int val) { carbohydrate = val; }
}
```

**使用方式：**

```java
NutritionFacts cocaCola = new NutritionFacts();
cocaCola.setServingSize(240);
cocaCola.setServings(8);
cocaCola.setCalories(100);
cocaCola.setSodium(35);
cocaCola.setCarbohydrate(27);
```

**缺點：**

- **狀態不一致**：物件建立過程中可能處於不完整狀態
- **除錯困難**：在不一致狀態下操作可能產生難以追蹤的 bug
- **無法保證不可變性**：物件建立後仍可修改
- **執行緒安全問題**：需要額外的同步機制

### 3. Builder Pattern (推薦)

Builder pattern 結合了前兩種方法的優點，同時避免了它們的缺點：

```java
public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    public static class Builder {
        // Required parameters
        private final int servingSize;
        private final int servings;

        // Optional parameters - initialized to default values
        private int calories      = 0;
        private int fat           = 0;
        private int sodium        = 0;
        private int carbohydrate  = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings    = servings;
        }

        public Builder calories(int val) {
            calories = val;
            return this;
        }

        public Builder fat(int val) {
            fat = val;
            return this;
        }

        public Builder sodium(int val) {
            sodium = val;
            return this;
        }

        public Builder carbohydrate(int val) {
            carbohydrate = val;
            return this;
        }

        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder) {
        servingSize  = builder.servingSize;
        servings     = builder.servings;
        calories     = builder.calories;
        fat          = builder.fat;
        sodium       = builder.sodium;
        carbohydrate = builder.carbohydrate;
    }
}
```

**使用方式：**

```java
NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)
        .calories(100)
        .sodium(35)
        .carbohydrate(27)
        .build();
```

## Builder Pattern 的優點

### 1. Fluent API

Builder 的每個方法都回傳自身物件，讓客戶端可以鏈式呼叫，這種寫法稱為 **Fluent API**。

### 2. 類似 Named Parameters

提供了類似於 Python、Scala 或 Kotlin 的 **named optional parameters** 的寫法，讓程式碼更具表達性。

### 3. 保證物件一致性

- 透過 private constructor 確保只能透過 Builder 建立物件
- 物件建立完成後是完整且一致的狀態
- 支援不可變物件的建立

## 參數驗證

建議在兩個地方進行驗證：

### Builder 層級驗證

```java
public Builder calories(int val) {
    if (val < 0) throw new IllegalArgumentException("calories must be non-negative");
    calories = val;
    return this;
}
```

### 物件層級驗證

```java
private NutritionFacts(Builder builder) {
    // 個別參數檢查在 Builder 中進行
    // 這裡進行整體物件的一致性檢查
    if (builder.servingSize <= 0 || builder.servings <= 0) {
        throw new IllegalArgumentException("serving size and servings must be positive");
    }

    servingSize  = builder.servingSize;
    servings     = builder.servings;
    calories     = builder.calories;
    fat          = builder.fat;
    sodium       = builder.sodium;
    carbohydrate = builder.carbohydrate;
}
```

## 實務建議

### 何時使用 Builder Pattern

- **參數數量**：通常 constructor 參數超過 **4 個** 時適用
- **可選參數**：大部分參數是可選的情況
- **複雜物件**：物件建立邏輯較為複雜

### 簡化實作方式

!!! tip "使用 Lombok @Builder"

    可以使用 [Lombok @Builder](https://projectlombok.org/features/Builder) 註解來自動生成 Builder 程式碼，大幅簡化實作：

    ```java
    @Builder
    public class NutritionFacts {
        private final int servingSize;
        private final int servings;
        private final int calories;
        private final int fat;
        private final int sodium;
        private final int carbohydrate;
    }
    ```

## 總結

Builder pattern 在面對多參數 constructor 時提供了優雅的解決方案：

✅ **可讀性佳**：程式碼清楚表達每個參數的意義
✅ **類型安全**：編譯時期就能發現參數錯誤
✅ **支援不可變性**：建立後無法修改的物件
✅ **彈性擴展**：新增參數不影響現有程式碼

雖然需要額外的程式碼，但在複雜物件建立的場景中，這些投資是值得的。
