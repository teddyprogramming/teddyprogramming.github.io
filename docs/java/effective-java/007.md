# Item 7: Eliminate obsolete object references

消除過時的物件參考，避免無意中的記憶體洩漏 (memory leak)。

## 問題：過時物件參考

### 範例：Stack 實作的記憶4. **程式碼審查**：特別注意集合類別和快取的實作

!!! tip "核心原則"
    **大部分情況下，變數用完就會自動被 GC 回收，不需要手動設為 null。**

    ```java
    // ✅ 一般情況：不需要手動設 null
    public void processData() {
        List<String> data = getData();
        doSomething(data);
        // data 在方法結束時自動被回收，不需要 data = null
    }

    // ❌ 特殊情況：自己管理記憶體才需要手動清除
    public Object pop() {
        Object result = elements[--size];
        elements[size] = null; // 必須手動清除，因為陣列還在使用中
        return result;
    }
    ```
```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    // ❌ 問題：沒有清除過時參考
    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        return elements[--size]; // 物件仍然被參考！
    }

    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}
```

### 問題說明

當執行 `pop()` 後：

- 元素被回傳給呼叫端
- 但 stack 內部的陣列仍然保持對該物件的參考
- 即使外部已無參考，該物件也無法被 GC 回收
- 造成 **記憶體洩漏**

這種指向不再維護的參考稱為 **obsolete object reference** (過時物件參考)。

### ✅ 解決方案

```java
public Object pop() {
    if (size == 0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null; // 清除過時參考
    return result;
}
```

!!! warning "重要原則"
    **將物件參考設為 null 應該是例外，而不是常態。** 只有在類別自己管理記憶體時才需要這樣做。

## 常見的記憶體洩漏來源

### 1. 自己管理記憶體的類別

- **問題**：Stack、ArrayList 等自己管理內部陣列
- **解決**：在移除元素時主動設為 null

### 2. 快取 (Cache)

**問題**：快取的物件可能永遠不會被移除

**解決方案：**

- **WeakHashMap**：當 key 不再被使用時自動移除

  ```java
  Map<Key, Value> cache = new WeakHashMap<>();
  ```

- **定期清理**：使用 ScheduledThreadPoolExecutor
- **LRU 策略**：LinkedHashMap 的 removeEldestEntry 方法
- **複雜快取**：使用 java.lang.ref 套件

### 3. Listener 和 Callback

**問題**：註冊後忘記取消註冊

**解決方案：**

- 使用 weak reference 儲存 callback
- 提供明確的取消註冊方法
- 在物件銷毀時自動清理

## 最佳實務

### 何時需要手動清除參考

✅ **需要**：

- 自己管理記憶體的類別（如 Stack、ArrayList）
- 快取實作
- Observer pattern 的實作
- 長生命週期的物件持有短生命週期物件參考

❌ **不需要**：

- 一般的區域變數
- 由 GC 自動管理的物件
- 生命週期相同的物件參考

### 實用技巧

1. **使用 IDE 警告**：現代 IDE 會警告可能的記憶體洩漏
2. **記憶體分析工具**：使用 JVisualVM、Eclipse MAT 等工具
3. **單元測試**：測試大量操作後的記憶體使用量
4. **程式碼審查**：特別注意集合類別和快取的實作

!!! tip "核心原則"
    **大部分情況下，讓變數在使用完後自然超出範圍即可，不需要手動設為 null。** 只有在自己管理記憶體 (如實作 Stack、Cache) 時才需要主動清除參考。
